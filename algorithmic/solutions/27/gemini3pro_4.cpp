#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

struct Point {
    int r, c;
};

// Returns weights of columns generated by prime p for R rows
// This function calculates the number of points in each column without constructing the full columns
vector<int> get_affine_weights(int p, int R) {
    int k = (R - 1) / p; // number of fully filled x-indices (0 to k-1)
    int rem = (R - 1) % p + 1; // number of valid y-indices in the partial x-index k
    
    vector<int> weights;
    weights.reserve(p * p + p);
    
    // Type 1 lines: y = ax + b (mod p)
    // These correspond to p*p columns
    for (int a = 0; a < p; ++a) {
        for (int b = 0; b < p; ++b) {
            // Points from full x-columns 0..k-1 contribute k points
            int w = k;
            // Point from partial x-column k contributes 1 if the y-value is valid
            // y = (a*k + b) % p
            // Valid if y < rem (i.e., y is in 0..rem-1)
            if (((a * k + b) % p) < rem) {
                w++;
            }
            weights.push_back(w);
        }
    }
    
    // Type 2 lines: x = c
    // These correspond to p vertical columns
    for (int c = 0; c < p; ++c) {
        int w = 0;
        if (c < k) w = p;       // Full column
        else if (c == k) w = rem; // Partial column
        else w = 0;             // Empty column (x-index out of range)
        weights.push_back(w);
    }
    return weights;
}

// Reconstruct the actual column contents for the best prime p
// Returns a list of columns, where each column is a vector of row indices
vector<vector<int>> generate_affine_columns(int p, int R) {
    int k = (R - 1) / p;
    int rem = (R - 1) % p + 1;
    
    vector<pair<int, vector<int>>> cols;
    cols.reserve(p*p + p);

    // Type 1 lines: y = ax + b
    for (int a = 0; a < p; ++a) {
        for (int b = 0; b < p; ++b) {
            vector<int> rows;
            // x from 0 to k-1 (full columns in the affine grid)
            for (int x = 0; x < k; ++x) {
                int y = (a * x + b) % p;
                // Map affine coordinate (x, y) to row index x*p + y
                rows.push_back(x * p + y);
            }
            // x = k (partial column)
            int y_k = (a * k + b) % p;
            if (y_k < rem) {
                rows.push_back(k * p + y_k);
            }
            cols.push_back({(int)rows.size(), rows});
        }
    }
    
    // Type 2 lines: x = c
    for (int c = 0; c < p; ++c) {
        vector<int> rows;
        if (c < k) {
            for (int y = 0; y < p; ++y) rows.push_back(c * p + y);
        } else if (c == k) {
            for (int y = 0; y < rem; ++y) rows.push_back(c * p + y);
        }
        cols.push_back({(int)rows.size(), rows});
    }

    // Sort descending by size (weight) to pick the best columns
    sort(cols.begin(), cols.end(), [](const pair<int, vector<int>>& a, const pair<int, vector<int>>& b){
        return a.first > b.first;
    });

    vector<vector<int>> res;
    res.reserve(cols.size());
    for(auto& p : cols) res.push_back(p.second);
    return res;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, m;
    if (!(cin >> n >> m)) return 0;

    // Normalize to R <= C to simplify logic (transpose at the end if needed)
    bool transposed = false;
    int R = n, C = m;
    if (n > m) {
        swap(R, C);
        transposed = true;
    }

    long long max_points = -1;
    int best_strategy = 0; // 0: All Pairs, 1: Affine
    int best_p = -1;

    // Strategy 0: All Pairs
    // Construct columns of weight 2 for every pair of rows.
    // If we have more columns C than pairs, fill remaining with weight 1.
    // If we have fewer columns C than pairs, take C pairs.
    long long pairs_count = (long long)R * (R - 1) / 2;
    long long pts_pairs = 0;
    if (C <= pairs_count) {
        pts_pairs = (long long)C * 2;
    } else {
        pts_pairs = pairs_count * 2 + (C - pairs_count);
    }
    
    max_points = pts_pairs;
    best_strategy = 0;

    // Strategy 1: Truncated Affine Plane
    // Iterate over primes p <= R.
    // Map R rows to a subset of the p x p affine grid points.
    // Select the best C columns (lines in the affine plane) based on weight.
    int limit = R + 1;
    vector<bool> is_prime(limit + 1, true);
    is_prime[0] = is_prime[1] = false;
    vector<int> primes;
    for (int p = 2; p <= limit; ++p) {
        if (is_prime[p]) {
            primes.push_back(p);
            for (int i = 2 * p; i <= limit; i += p)
                is_prime[i] = false;
        }
    }

    for (int p : primes) {
        if (p > R) break;
        
        vector<int> weights = get_affine_weights(p, R);
        sort(weights.begin(), weights.end(), greater<int>());
        
        long long current_pts = 0;
        int num_lines = weights.size();
        int take = min(C, num_lines);
        
        for(int i=0; i<take; ++i) current_pts += weights[i];
        
        // If we still have columns to fill, fill with weight 1 (always valid)
        if (C > num_lines) {
            current_pts += (C - num_lines);
        }

        if (current_pts > max_points) {
            max_points = current_pts;
            best_strategy = 1;
            best_p = p;
        }
    }

    // Generate output based on the best strategy
    vector<Point> ans;
    
    if (best_strategy == 0) {
        // Generate pairs for Strategy 0
        int count = 0;
        for (int i = 0; i < R && count < C; ++i) {
            for (int j = i + 1; j < R && count < C; ++j) {
                ans.push_back({i + 1, count + 1});
                ans.push_back({j + 1, count + 1});
                count++;
            }
        }
        // Fill remaining columns with row 1
        while (count < C) {
            ans.push_back({1, count + 1});
            count++;
        }
    } else {
        // Generate columns for Strategy 1
        vector<vector<int>> cols = generate_affine_columns(best_p, R);
        int num_lines = cols.size();
        for (int i = 0; i < C; ++i) {
            if (i < num_lines) {
                for (int r_idx : cols[i]) {
                    ans.push_back({r_idx + 1, i + 1});
                }
            } else {
                // Weight 1 filler
                ans.push_back({1, i + 1});
            }
        }
    }

    cout << ans.size() << "\n";
    for (const auto& pt : ans) {
        if (!transposed) {
            cout << pt.r << " " << pt.c << "\n";
        } else {
            cout << pt.c << " " << pt.r << "\n";
        }
    }

    return 0;
}