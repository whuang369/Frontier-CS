import json
import os


class Solution:
    def solve(self, spec_path: str = None) -> dict:
        num_vms = 2
        ingress_limits = {"aws": 10, "gcp": 16, "azure": 16}
        egress_limits = {"aws": 5, "gcp": 7, "azure": 16}

        if spec_path:
            try:
                with open(spec_path, "r") as f:
                    spec = json.load(f)
                if isinstance(spec, dict):
                    if "num_vms" in spec:
                        try:
                            num_vms = int(spec["num_vms"])
                        except (TypeError, ValueError):
                            pass
                    config_files = spec.get("config_files") or []
                    if config_files:
                        first_cfg = config_files[0]
                        if not os.path.isabs(first_cfg):
                            base_dir = os.path.dirname(spec_path)
                            cfg_path = os.path.join(base_dir, first_cfg)
                        else:
                            cfg_path = first_cfg
                        try:
                            with open(cfg_path, "r") as cf:
                                cfg = json.load(cf)
                            ing = cfg.get("ingress_limit")
                            if isinstance(ing, dict):
                                for k, v in ing.items():
                                    try:
                                        ingress_limits[str(k).lower()] = float(v)
                                    except (TypeError, ValueError):
                                        continue
                            egr = cfg.get("egress_limit")
                            if isinstance(egr, dict):
                                for k, v in egr.items():
                                    try:
                                        egress_limits[str(k).lower()] = float(v)
                                    except (TypeError, ValueError):
                                        continue
                        except Exception:
                            pass
            except Exception:
                pass

        ingress_limits = {str(k).lower(): float(v) for k, v in ingress_limits.items()}
        egress_limits = {str(k).lower(): float(v) for k, v in egress_limits.items()}

        lines = []
        lines.append("import networkx as nx")
        lines.append("from collections import defaultdict")
        lines.append("")
        lines.append(f"NUM_VMS = {num_vms}")
        lines.append(f"INGRESS_LIMITS = {repr(ingress_limits)}")
        lines.append(f"EGRESS_LIMITS = {repr(egress_limits)}")
        lines.append("")
        lines.append("")
        lines.append("class BroadCastTopology:")
        lines.append("    def __init__(self, src, dsts, num_partitions):")
        lines.append("        self.src = src")
        lines.append("        self.dsts = dsts")
        lines.append("        self.num_partitions = int(num_partitions)")
        lines.append("        # Structure: {dst: {partition_id: [edges]}}")
        lines.append("        self.paths = {dst: {str(i): None for i in range(self.num_partitions)} for dst in dsts}")
        lines.append("")
        lines.append("    def append_dst_partition_path(self, dst, partition, path):")
        lines.append("        partition = str(partition)")
        lines.append("        if self.paths[dst][partition] is None:")
        lines.append("            self.paths[dst][partition] = []")
        lines.append("        self.paths[dst][partition].append(path)")
        lines.append("")
        lines.append("    def set_dst_partition_paths(self, dst, partition, paths):")
        lines.append("        partition = str(partition)")
        lines.append("        self.paths[dst][partition] = paths")
        lines.append("")
        lines.append("    def set_num_partitions(self, num_partitions):")
        lines.append("        self.num_partitions = num_partitions")
        lines.append("")
        lines.append("")
        lines.append("def _get_provider(node):")
        lines.append("    if not isinstance(node, str):")
        lines.append("        return None")
        lines.append("    return node.split(':', 1)[0].lower()")
        lines.append("")
        lines.append("")
        lines.append("def search_algorithm(src, dsts, G, num_partitions):")
        lines.append("    bc_topology = BroadCastTopology(src, dsts, num_partitions)")
        lines.append("")
        lines.append("    if not isinstance(G, nx.DiGraph):")
        lines.append("        G = nx.DiGraph(G)")
        lines.append("")
        lines.append("    # Precompute effective throughput and static cost per edge")
        lines.append("    eff_throughput = {}")
        lines.append("    static_cost = {}")
        lines.append("    original_throughput = {}")
        lines.append("")
        lines.append("    for u, v, data in G.edges(data=True):")
        lines.append("        cost = float(data.get('cost', 0.0))")
        lines.append("        throughput = data.get('throughput', 0.0)")
        lines.append("        try:")
        lines.append("            throughput = float(throughput)")
        lines.append("        except (TypeError, ValueError):")
        lines.append("            throughput = 0.0")
        lines.append("        if throughput <= 0.0:")
        lines.append("            throughput = 1e-6")
        lines.append("")
        lines.append("        prov_u = _get_provider(u)")
        lines.append("        prov_v = _get_provider(v)")
        lines.append("")
        lines.append("        egress_cap = EGRESS_LIMITS.get(prov_u, float('inf')) * NUM_VMS")
        lines.append("        ingress_cap = INGRESS_LIMITS.get(prov_v, float('inf')) * NUM_VMS")
        lines.append("")
        lines.append("        eff = throughput")
        lines.append("        if egress_cap > 0:")
        lines.append("            eff = min(eff, float(egress_cap))")
        lines.append("        if ingress_cap > 0:")
        lines.append("            eff = min(eff, float(ingress_cap))")
        lines.append("        if eff <= 0.0:")
        lines.append("            eff = 1e-6")
        lines.append("")
        lines.append("        eff_throughput[(u, v)] = eff")
        lines.append("        original_throughput[(u, v)] = throughput")
        lines.append("        static_cost[(u, v)] = cost")
        lines.append("")
        lines.append("    if not static_cost:")
        lines.append("        return bc_topology")
        lines.append("")
        lines.append("    cost_values = list(static_cost.values())")
        lines.append("    thr_values = list(eff_throughput.values())")
        lines.append("")
        lines.append("    cost_min = min(cost_values)")
        lines.append("    cost_max = max(cost_values)")
        lines.append("    thr_min = min(thr_values)")
        lines.append("    thr_max = max(thr_values)")
        lines.append("")
        lines.append("    cost_span = cost_max - cost_min")
        lines.append("    if cost_span <= 0.0:")
        lines.append("        cost_span = 1.0")
        lines.append("    thr_span = thr_max - thr_min")
        lines.append("    if thr_span <= 0.0:")
        lines.append("        thr_span = 1.0")
        lines.append("")
        lines.append("    # Build a static base score per edge balancing cost and throughput")
        lines.append("    base_edge_score = {}")
        lines.append("    w_cost = 0.6")
        lines.append("    w_thr = 0.25")
        lines.append("    w_limit = 0.15")
        lines.append("")
        lines.append("    for (u, v), cost in static_cost.items():")
        lines.append("        eff = eff_throughput[(u, v)]")
        lines.append("        thr_norm = (thr_max - eff) / thr_span  # lower eff -> larger value")
        lines.append("        cost_norm = (cost - cost_min) / cost_span")
        lines.append("")
        lines.append("        throughput_orig = original_throughput[(u, v)]")
        lines.append("        limit_penalty = 0.0")
        lines.append("        if throughput_orig > 0.0:")
        lines.append("            limit_factor = eff / throughput_orig")
        lines.append("            if limit_factor < 1.0:")
        lines.append("                limit_penalty = 1.0 - limit_factor")
        lines.append("")
        lines.append("        base_score = w_cost * cost_norm + w_thr * thr_norm + w_limit * limit_penalty")
        lines.append("        if base_score <= 0.0:")
        lines.append("            base_score = 1e-6")
        lines.append("        base_edge_score[(u, v)] = base_score")
        lines.append("")
        lines.append("    # For each destination, precompute a set of candidate paths using k-shortest by cost")
        lines.append("    candidate_paths_edges = {}")
        lines.append("")
        lines.append("    try:")
        lines.append("        max_paths_per_dst = max(3, min(8, int(num_partitions)))")
        lines.append("    except (TypeError, ValueError):")
        lines.append("        max_paths_per_dst = 3")
        lines.append("")
        lines.append("    def _cost_weight(u, v, data):")
        lines.append("        val = data.get('cost', 0.0)")
        lines.append("        try:")
        lines.append("            return float(val)")
        lines.append("        except (TypeError, ValueError):")
        lines.append("            return 0.0")
        lines.append("")
        lines.append("    for dst in dsts:")
        lines.append("        paths_edges = []")
        lines.append("        if src == dst:")
        lines.append("            candidate_paths_edges[dst] = [[]]")
        lines.append("            continue")
        lines.append("        try:")
        lines.append("            gen = nx.shortest_simple_paths(G, src, dst, weight=_cost_weight)")
        lines.append("            for path in gen:")
        lines.append("                if not path or len(path) < 2:")
        lines.append("                    continue")
        lines.append("                edges = []")
        lines.append("                valid = True")
        lines.append("                for i in range(len(path) - 1):")
        lines.append("                    u = path[i]")
        lines.append("                    v = path[i + 1]")
        lines.append("                    if not G.has_edge(u, v):")
        lines.append("                        valid = False")
        lines.append("                        break")
        lines.append("                    edges.append((u, v))")
        lines.append("                if not valid:")
        lines.append("                    continue")
        lines.append("                paths_edges.append(edges)")
        lines.append("                if len(paths_edges) >= max_paths_per_dst:")
        lines.append("                    break")
        lines.append("        except (nx.NetworkXNoPath, nx.NodeNotFound):")
        lines.append("            paths_edges = []")
        lines.append("")
        lines.append("        # Fallback to a single shortest path if no candidate path was found")
        lines.append("        if not paths_edges:")
        lines.append("            try:")
        lines.append("                path = nx.dijkstra_path(G, src, dst, weight=_cost_weight)")
        lines.append("                if len(path) >= 2:")
        lines.append("                    edges = [(path[i], path[i + 1]) for i in range(len(path) - 1)]")
        lines.append("                    paths_edges.append(edges)")
        lines.append("            except (nx.NetworkXNoPath, nx.NodeNotFound):")
        lines.append("                paths_edges = []")
        lines.append("")
        lines.append("        if not paths_edges:")
        lines.append("            candidate_paths_edges[dst] = [[]]")
        lines.append("        else:")
        lines.append("            candidate_paths_edges[dst] = paths_edges")
        lines.append("")
        lines.append("    # Dynamic assignment of partitions to paths to balance edge load")
        lines.append("    edge_usage = defaultdict(int)")
        lines.append("    gamma_edge = 1.3")
        lines.append("")
        lines.append("    try:")
        lines.append("        total_parts = int(num_partitions)")
        lines.append("    except (TypeError, ValueError):")
        lines.append("        total_parts = 1")
        lines.append("")
        lines.append("    for part in range(total_parts):")
        lines.append("        for dst in dsts:")
        lines.append("            paths_edges = candidate_paths_edges.get(dst)")
        lines.append("            if not paths_edges:")
        lines.append("                continue")
        lines.append("")
        lines.append("            best_idx = 0")
        lines.append("            best_score = None")
        lines.append("")
        lines.append("            for idx, edges in enumerate(paths_edges):")
        lines.append("                if not edges:")
        lines.append("                    score = 0.0")
        lines.append("                else:")
        lines.append("                    score = 0.0")
        lines.append("                    for (u, v) in edges:")
        lines.append("                        base = base_edge_score.get((u, v), 1.0)")
        lines.append("                        usage = edge_usage[(u, v)]")
        lines.append("                        factor = (1.0 + float(usage)) ** gamma_edge")
        lines.append("                        score += base * factor")
        lines.append("")
        lines.append("                if best_score is None or score < best_score:")
        lines.append("                    best_score = score")
        lines.append("                    best_idx = idx")
        lines.append("")
        lines.append("            selected_edges = paths_edges[best_idx]")
        lines.append("")
        lines.append("            path_records = []")
        lines.append("            for (u, v) in selected_edges:")
        lines.append("                path_records.append([u, v, G[u][v]])")
        lines.append("                edge_usage[(u, v)] += 1")
        lines.append("")
        lines.append("            bc_topology.set_dst_partition_paths(dst, part, path_records)")
        lines.append("")
        lines.append("    return bc_topology")
        lines.append("")

        code = "\n".join(lines)
        return {"code": code}