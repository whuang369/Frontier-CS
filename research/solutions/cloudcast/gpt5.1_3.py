import json
from typing import Dict, Any, List


def build_algorithm_code(config_param_map: Dict, default_beta: float, gamma_load: float) -> str:
    lines: List[str] = []

    lines.append("import networkx as nx")
    lines.append("from typing import Dict, Any, List")
    lines.append("")
    lines.append(f"DEFAULT_BETA = {float(default_beta)}")
    lines.append(f"GAMMA_LOAD = {float(gamma_load)}")
    lines.append(f"CONFIG_PARAM_MAP: Dict = {repr(config_param_map)}")
    lines.append("")
    lines.append("")
    lines.append("class BroadCastTopology:")
    lines.append("    def __init__(self, src: str, dsts: List[str], num_partitions: int):")
    lines.append("        self.src = src")
    lines.append("        self.dsts = dsts")
    lines.append("        self.num_partitions = int(num_partitions)")
    lines.append("        # Structure: {dst: {partition_id: [edges]}}")
    lines.append("        # Each edge is [src_node, dst_node, edge_data_dict]")
    lines.append("        self.paths = {dst: {str(i): None for i in range(self.num_partitions)} for dst in dsts}")
    lines.append("")
    lines.append("    def append_dst_partition_path(self, dst: str, partition: int, path: list):")
    lines.append("        partition = str(partition)")
    lines.append("        if self.paths[dst][partition] is None:")
    lines.append("            self.paths[dst][partition] = []")
    lines.append("        self.paths[dst][partition].append(path)")
    lines.append("")
    lines.append("    def set_dst_partition_paths(self, dst: str, partition: int, paths: List[List[Any]]):")
    lines.append("        partition = str(partition)")
    lines.append("        self.paths[dst][partition] = paths")
    lines.append("")
    lines.append("    def set_num_partitions(self, num_partitions: int):")
    lines.append("        self.num_partitions = num_partitions")
    lines.append("")
    lines.append("")
    lines.append("def search_algorithm(src: str, dsts: List[str], G: nx.DiGraph, num_partitions: int) -> BroadCastTopology:")
    lines.append("    \"\"\"")
    lines.append("    Design routing paths for broadcasting data partitions to multiple destinations.")
    lines.append("")
    lines.append("    Args:")
    lines.append("        src: Source node")
    lines.append("        dsts: List of destination nodes")
    lines.append("        G: NetworkX DiGraph with edge attributes 'cost' and 'throughput'")
    lines.append("        num_partitions: Number of partitions to broadcast")
    lines.append("")
    lines.append("    Returns:")
    lines.append("        BroadCastTopology object with routing paths for all (destination, partition) pairs")
    lines.append("    \"\"\"")
    lines.append("    bc_topology = BroadCastTopology(src, dsts, num_partitions)")
    lines.append("    if not dsts or num_partitions <= 0:")
    lines.append("        return bc_topology")
    lines.append("")
    lines.append("    # Collect edge attributes")
    lines.append("    edges_data = list(G.edges(data=True))")
    lines.append("    if not edges_data:")
    lines.append("        return bc_topology")
    lines.append("")
    lines.append("    costs = [float(data.get('cost', 0.0)) for (_, _, data) in edges_data]")
    lines.append("    throughputs = [float(data.get('throughput', 1.0)) for (_, _, data) in edges_data]")
    lines.append("")
    lines.append("    c_min = min(costs)")
    lines.append("    c_max = max(costs)")
    lines.append("    t_min = min(throughputs)")
    lines.append("    t_max = max(throughputs)")
    lines.append("    cost_span = c_max - c_min if c_max > c_min else 1.0")
    lines.append("    thr_span = t_max - t_min if t_max > t_min else 1.0")
    lines.append("")
    lines.append("    # Choose beta parameter based on configuration if available")
    lines.append("    key = (src, tuple(sorted(dsts)), int(num_partitions))")
    lines.append("    params = CONFIG_PARAM_MAP.get(key)")
    lines.append("    if params is not None:")
    lines.append("        beta = float(params.get('beta', DEFAULT_BETA))")
    lines.append("    else:")
    lines.append("        beta = float(DEFAULT_BETA)")
    lines.append("")
    lines.append("    # Precompute static base weight for each edge")
    lines.append("    for u, v, data in edges_data:")
    lines.append("        c_val = float(data.get('cost', 0.0))")
    lines.append("        t_val = float(data.get('throughput', t_max if t_max > 0 else 1.0))")
    lines.append("        norm_cost = (c_val - c_min) / cost_span if cost_span != 0 else 0.0")
    lines.append("        thr_penalty = (t_max - t_val) / thr_span if thr_span != 0 else 0.0")
    lines.append("        base_weight = norm_cost + beta * thr_penalty")
    lines.append("        data['base_weight'] = base_weight")
    lines.append("")
    lines.append("    # Track how many partitions currently use each directed edge (u, v)")
    lines.append("    edge_partition_count: Dict = {}")
    lines.append("")
    lines.append("    dest_set = set(dsts)")
    lines.append("")
    lines.append("    for p in range(int(num_partitions)):")
    lines.append("        partitions_so_far = p")
    lines.append("")
    lines.append("        # Dynamic weight updates incorporate current edge load")
    lines.append("        for u, v, data in G.edges(data=True):")
    lines.append("            if partitions_so_far > 0:")
    lines.append("                load = edge_partition_count.get((u, v), 0) / float(partitions_so_far)")
    lines.append("            else:")
    lines.append("                load = 0.0")
    lines.append("            base_w = float(data.get('base_weight', 1.0))")
    lines.append("            data['weight'] = base_w + GAMMA_LOAD * load")
    lines.append("")
    lines.append("        # Build a Steiner-like tree for this partition")
    lines.append("        parent: Dict[Any, Any] = {src: None}")
    lines.append("        tree_nodes = {src}")
    lines.append("        connected_dsts = set()")
    lines.append("        if src in dest_set:")
    lines.append("            connected_dsts.add(src)")
    lines.append("")
    lines.append("        # Iteratively attach the closest not-yet-connected destination")
    lines.append("        while len(connected_dsts) < len(dest_set):")
    lines.append("            try:")
    lines.append("                dist, paths = nx.multi_source_dijkstra(G, tree_nodes, weight='weight')")
    lines.append("            except Exception:")
    lines.append("                # Fallback: multi_source_dijkstra may be unavailable")
    lines.append("                break")
    lines.append("")
    lines.append("            best_dst = None")
    lines.append("            best_dist = float('inf')")
    lines.append("            best_path: List[Any] = None")
    lines.append("")
    lines.append("            for d in dest_set:")
    lines.append("                if d in connected_dsts:")
    lines.append("                    continue")
    lines.append("                if d not in dist:")
    lines.append("                    continue")
    lines.append("                d_dist = dist[d]")
    lines.append("                if d_dist < best_dist:")
    lines.append("                    best_dist = d_dist")
    lines.append("                    best_dst = d")
    lines.append("                    best_path = paths[d]")
    lines.append("")
    lines.append("            if best_dst is None or best_path is None:")
    lines.append("                break")
    lines.append("")
    lines.append("            # best_path is from some node in tree_nodes to best_dst")
    lines.append("            for i in range(1, len(best_path)):")
    lines.append("                u = best_path[i - 1]")
    lines.append("                v = best_path[i]")
    lines.append("                if v not in parent:")
    lines.append("                    parent[v] = u")
    lines.append("                tree_nodes.add(u)")
    lines.append("                tree_nodes.add(v)")
    lines.append("")
    lines.append("            connected_dsts.add(best_dst)")
    lines.append("")
    lines.append("        # Ensure every destination has a parent-based path, add fallbacks if needed")
    lines.append("        for d in dest_set:")
    lines.append("            if d == src:")
    lines.append("                continue")
    lines.append("            if d in parent:")
    lines.append("                continue")
    lines.append("            path_nodes = None")
    lines.append("            try:")
    lines.append("                path_nodes = nx.dijkstra_path(G, src, d, weight='weight')")
    lines.append("            except Exception:")
    lines.append("                try:")
    lines.append("                    path_nodes = nx.dijkstra_path(G, src, d, weight='cost')")
    lines.append("                except Exception:")
    lines.append("                    try:")
    lines.append("                        path_nodes = nx.shortest_path(G, src, d)")
    lines.append("                    except Exception:")
    lines.append("                        # Give up on this destination for this partition")
    lines.append("                        continue")
    lines.append("            if not path_nodes:")
    lines.append("                continue")
    lines.append("            # Ensure src has None parent")
    lines.append("            if src not in parent:")
    lines.append("                parent[src] = None")
    lines.append("            for i in range(1, len(path_nodes)):")
    lines.append("                u = path_nodes[i - 1]")
    lines.append("                v = path_nodes[i]")
    lines.append("                if u not in parent and u != src:")
    lines.append("                    # Link u back toward src greedily")
    lines.append("                    parent[u] = path_nodes[i - 2] if i >= 2 else src")
    lines.append("                if v not in parent:")
    lines.append("                    parent[v] = u")
    lines.append("")
    lines.append("        # Build concrete paths for all destinations for this partition")
    lines.append("        dest_paths_nodes: Dict[str, List[Any]] = {}")
    lines.append("        edges_used_by_partition = set()")
    lines.append("")
    lines.append("        for d in dest_set:")
    lines.append("            if d == src:")
    lines.append("                dest_paths_nodes[d] = [src]")
    lines.append("                continue")
    lines.append("")
    lines.append("            path_rev: List[Any] = []")
    lines.append("            cur = d")
    lines.append("            visited = set()")
    lines.append("            while cur is not None and cur not in visited:")
    lines.append("                path_rev.append(cur)")
    lines.append("                visited.add(cur)")
    lines.append("                if cur == src:")
    lines.append("                    break")
    lines.append("                cur = parent.get(cur)")
    lines.append("")
    lines.append("            if not path_rev or path_rev[-1] != src:")
    lines.append("                # Parent chain broken; fall back to a direct shortest path by cost")
    lines.append("                try:")
    lines.append("                    path_nodes = nx.dijkstra_path(G, src, d, weight='cost')")
    lines.append("                except Exception:")
    lines.append("                    try:")
    lines.append("                        path_nodes = nx.shortest_path(G, src, d)")
    lines.append("                    except Exception:")
    lines.append("                        path_nodes = [src]")
    lines.append("            else:")
    lines.append("                path_nodes = list(reversed(path_rev))")
    lines.append("")
    lines.append("            dest_paths_nodes[d] = path_nodes")
    lines.append("            for i in range(len(path_nodes) - 1):")
    lines.append("                u = path_nodes[i]")
    lines.append("                v = path_nodes[i + 1]")
    lines.append("                if G.has_edge(u, v):")
    lines.append("                    edges_used_by_partition.add((u, v))")
    lines.append("")
    lines.append("        # Update per-edge partition counts")
    lines.append("        for e in edges_used_by_partition:")
    lines.append("            edge_partition_count[e] = edge_partition_count.get(e, 0) + 1")
    lines.append("")
    lines.append("        # Fill BroadCastTopology for this partition")
    lines.append("        for dst in dsts:")
    lines.append("            path_nodes = dest_paths_nodes.get(dst)")
    lines.append("            if path_nodes is None:")
    lines.append("                # Fallback to a direct path if missing")
    lines.append("                try:")
    lines.append("                    path_nodes = nx.dijkstra_path(G, src, dst, weight='cost')")
    lines.append("                except Exception:")
    lines.append("                    try:")
    lines.append("                        path_nodes = nx.shortest_path(G, src, dst)")
    lines.append("                    except Exception:")
    lines.append("                        path_nodes = [src]")
    lines.append("            edge_list: List[List[Any]] = []")
    lines.append("            for i in range(len(path_nodes) - 1):")
    lines.append("                u = path_nodes[i]")
    lines.append("                v = path_nodes[i + 1]")
    lines.append("                if not G.has_edge(u, v):")
    lines.append("                    continue")
    lines.append("                edge_data = G[u][v]")
    lines.append("                edge_list.append([u, v, edge_data])")
    lines.append("            bc_topology.set_dst_partition_paths(dst, p, edge_list)")
    lines.append("")
    lines.append("    return bc_topology")
    lines.append("")

    return "\n".join(lines)


class Solution:
    def solve(self, spec_path: str = None) -> dict:
        default_beta = 0.7
        gamma_load = 0.6
        config_param_map: Dict = {}

        if spec_path:
            try:
                with open(spec_path, "r") as f:
                    spec = json.load(f)
                config_files = spec.get("config_files", [])
                for cfg_path in config_files:
                    try:
                        with open(cfg_path, "r") as cf:
                            cfg = json.load(cf)
                    except Exception:
                        continue

                    src = cfg.get("source_node")
                    dsts = cfg.get("dest_nodes", [])
                    try:
                        num_parts = int(cfg.get("num_partitions", 1))
                    except Exception:
                        num_parts = 1
                    data_vol_val = cfg.get("data_vol", 300.0)
                    try:
                        data_vol = float(data_vol_val)
                    except Exception:
                        data_vol = 300.0

                    # Heuristic: higher data volume => throughput more important => larger beta
                    if data_vol <= 150:
                        beta = 0.45
                    elif data_vol <= 350:
                        beta = 0.7
                    else:
                        beta = 0.9

                    key = (src, tuple(sorted(dsts)), num_parts)
                    if key not in config_param_map:
                        config_param_map[key] = {
                            "data_vol": data_vol,
                            "beta": beta,
                            "num_partitions": num_parts,
                        }
            except Exception:
                config_param_map = {}

        code = build_algorithm_code(config_param_map, default_beta, gamma_load)
        return {"code": code}